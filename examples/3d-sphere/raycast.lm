// Determines how to convert screen coordinates to raycast angles.
// This essentially defines how far behind the camera should all light be focused to.
// Then, an angle is computed between this point and the screen coordinate.
// Basically, this determines FoV.
inline const focal_length = 1;

export function r_aycast(x, y) {
    // First, figure out the euler angle of the ray that passes through this point.
    // This can be determined by finding the angle between (x, y, 0) and (x, y, -focal_length).
    // Then, use that angle to compute the world space position and rotation of the ray's start and end.
    // This can be used to intersect the ray with a sphere.
    
    const centered_point = [x, y, focal_length];
    const center_point_magnitude = sqrt((centered_point[1] ^ 2) + (centered_point[2] ^ 2) + (centered_point[3] ^ 2));
    
    const normalized_point = [centered_point[1] / center_point_magnitude, centered_point[2] / center_point_magnitude, centered_point[3] / center_point_magnitude];
    
    const dir_vec = c_amera_rotate(normalized_point);
    
    // This can be used to compute the ray start and end.
    const ray_start = [c_amera_x, c_amera_y, c_amera_z];
    
    raycast_sphere(ray_start, dir_vec)
}

inline function raycast_sphere(ray_start, ray_dir) {
    // https://gamedev.stackexchange.com/a/96487
    
    const sphere_pos = [3, 3, 3];
    const sphere_radius = 1;
    
    const m = ray_start - sphere_pos;
    const b = d_ot(m, ray_dir);
    const c = d_ot(m, m) - (sphere_radius ^ 2);
    
    if(c > 0 && b > 0) {
        b_g
    } else {
        const discr = (b^2) - c;
        
        if(discr < 0) {
            b_g
        } else {
            const t = max(0, -b - sqrt(discr));
            
            // Figure out where it hit.
            const hit_offset = t * ray_dir;
            const hit_pos = ray_start + hit_offset;
            
            // Find the sphere's normal.
            const sphere_hit_centered = hit_pos - sphere_pos;
            const sphere_hit_magnitude = sqrt((sphere_hit_centered[1] ^ 2) + (sphere_hit_centered[2] ^ 2) + (sphere_hit_centered[3] ^ 2));

            const sphere_hit_normal = [sphere_hit_centered[1] / sphere_hit_magnitude, sphere_hit_centered[2] / sphere_hit_magnitude, sphere_hit_centered[3] / sphere_hit_magnitude];
            
            // UV map the sphere.
            // This can be easily determined with the normal:
            // an x rotation specifies the u axes, and a z rotation
            // specifies the v.
            // These both need to be re-mapped from -1 to 1
            // to 0 to 1.
            const u = (sphere_hit_normal[1] + 1) / 2;
            const v = (sphere_hit_normal[3] + 1) / 2;
            
            u_v_to_color(u, v, sphere_hit_normal)
        }
    }
}

export function d_ot(a, b) {
    (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3])
}

// Based on https://en.wikipedia.org/wiki/Rotation_matrix#General_3D_rotations.
// 3x3 matrix
export const r_ot_mat = [
    cos(c_amera_rot_y) * cos(c_amera_rot_z), sin(c_amera_rot_x) * sin(c_amera_rot_y) * cos(c_amera_rot_z) - cos(c_amera_rot_x) * sin(c_amera_rot_z), cos(c_amera_rot_x) * sin(c_amera_rot_y) * cos(c_amera_rot_z) + sin(c_amera_rot_x) * sin(c_amera_rot_z),
    cos(c_amera_rot_y) * sin(c_amera_rot_z), sin(c_amera_rot_x) * sin(c_amera_rot_y) * sin(c_amera_rot_z) + cos(c_amera_rot_x) * cos(c_amera_rot_z), cos(c_amera_rot_x) * sin(c_amera_rot_y) * sin(c_amera_rot_z) - sin(c_amera_rot_x) * cos(c_amera_rot_z),
    -sin(c_amera_rot_y), sin(c_amera_rot_x) * cos(c_amera_rot_y), cos(c_amera_rot_x) * cos(c_amera_rot_y)
];

// 1-indexed
inline function get_rot(row, col) {
    r_ot_mat[3 * (row - 1) + col]
}

// Adds the camera's rotation to a specified vector.
export function c_amera_rotate(v_ec) {
    [
        v_ec[1] * get_rot(1, 1) + v_ec[2] * get_rot(1, 2) + v_ec[3] * get_rot(1, 3),
        v_ec[1] * get_rot(2, 1) + v_ec[2] * get_rot(2, 2) + v_ec[3] * get_rot(2, 3),
        v_ec[1] * get_rot(3, 1) + v_ec[2] * get_rot(3, 2) + v_ec[3] * get_rot(3, 3)
    ]
}

inline function gColor(num) {
    //Loop through the image, divided by the number of splits we turn the image into (this creates a single split).
    state = range(1, width * height/get!(SPLITS)).map(idx => {  
        //Get the x-position, centered at (0, 0).
        const x = conv_1d_2d_x(idx, width) - width/2;
        //Gets the y-position, centered at (0,0) and increased by the y-position of previous splits.
        const y = conv_1d_2d_y(idx, width) - height/2 + height*(num-1)/get!(SPLITS);
    
        const cX = x/r_es;
        const cY = y/r_es;
    
        r_aycast(cX, cY)
    });
}